C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 23:46:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.h>
   2          #include <intrins.h>
   3          
   4          #define LOW   0
   5          #define HIGH  1
   6          #define FALSE 0
   7          #define TRUE  1
   8          
   9          #define CLR_BIT(p,n) ((p) &= ~(1 << (n)))
  10          #define SET_BIT(p,n) ((p) |= (1 << (n)))
  11          
  12          // I/O Ports
  13          #define I_BUTTON      P34
  14          #define I_AVR_ONLINE  P33 // PD2
  15          #define O_BOOST       P35
  16          #define O_AVR_BUTTON  P32 // PD1
  17          
  18          // States
  19          #define SLEEP   0
  20          #define BOOT    1
  21          #define ONLINE  2
  22          
  23          volatile int state;
  24          volatile int button_changed;
  25          volatile int button_state;
  26          volatile int avr_online_state;
  27          
  28          
  29          void extInt2_ISR (void) interrupt 10
  30          {
  31   1        _nop_();
  32   1      }
  33          
  34          void timer0_ISR (void) interrupt 1
  35          {
  36   1        static float avg_button = 10;
  37   1        static float avg_avr_online = 10;
  38   1      
  39   1        int new_button_state;
  40   1        int new_avr_online_state;
  41   1      
  42   1        // Increment Counter to shorten overflow time
  43   1        TH0 = (65536 - 100) / 256; // TODO: Calculation?! Old: 1ms = 1000MZ, davon das High-Byte in TH0
  44   1        TL0 = (65536 - 100) % 256; // das Low-Byte in TL0
  45   1      
  46   1        // Button debouncing using exponential moving average
  47   1        // avg = alpha * avg + (1 - alpha) * input, alpha < 1
  48   1        // TODO: inefficient, replace
  49   1        avg_button     = 0.9 * avg_button + 0.1 * (I_BUTTON * 10);
  50   1        avg_avr_online = 0.9 * avg_avr_online + 0.1 * (I_AVR_ONLINE * 10);
  51   1      
  52   1        (avg_button > 5) ? (new_button_state = HIGH) : (new_button_state = LOW);
  53   1        (avg_avr_online > 5) ? (new_avr_online_state = HIGH) : (new_avr_online_state = LOW);
  54   1      
C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 23:46:49 PAGE 2   

  55   1        if (new_button_state != button_state) {
  56   2          button_state = new_button_state;
  57   2          button_changed = 1;
  58   2        } else {
  59   2          button_changed = 0;
  60   2        }
  61   1      
  62   1        if (new_avr_online_state != avr_online_state) {
  63   2          avr_online_state = new_avr_online_state;
  64   2        }
  65   1      }
  66          
  67          
  68          void setup()
  69          {
  70   1        // Keep P33 (I_AVR_ONLINE) and P34 (I_BUTTON) as Quasi-Bidirectional
  71   1        // since we need the internal PullUps
  72   1      
  73   1        // P35 (O_BOOST): PushPull Output
  74   1        SET_BIT(P3M0, 5);
  75   1        CLR_BIT(P3M1, 5);
  76   1      
  77   1        // P32 (O_AVR_BUTTON): PushPull Output
  78   1        SET_BIT(P3M1, 2);
  79   1        CLR_BIT(P3M1, 2);
  80   1      
  81   1        // Init States
  82   1        state = SLEEP;
  83   1        
  84   1        button_changed = FALSE;
  85   1        button_state = HIGH;
  86   1        avr_online_state = LOW;
  87   1      
  88   1        // Init I/O's
  89   1        O_AVR_BUTTON = HIGH;
  90   1        O_BOOST = LOW;
  91   1        I_BUTTON = HIGH;     // set to weak high => pullups!
  92   1        I_AVR_ONLINE = HIGH; // set to weak high => pullups!
  93   1      
  94   1        // Timers & Interrupts
  95   1        SET_BIT(INT_CLKO, 4);         // Interrupt on falling edge of INT2/P34 (Button)
  96   1        TMOD = (TMOD & 0xF0) | 0x01;  // Set T/C0 Mode 1, 16Bit, Manual Reload
  97   1        ET0 = 1;                      // Enable Timer 0 Interrupts
  98   1        TR0 = 1;                      // Start Timer 0 Running
  99   1      }
 100          
 101          void delay(int ms)
 102          {
 103   1          unsigned int j  =   0;
 104   1          unsigned int g  =   0;
 105   1          for(j=0;j<ms;j++)
 106   1          {
 107   2              for(g=0;g<600;g++)
 108   2              {
 109   3                  _nop_();
 110   3                  _nop_();
 111   3                  _nop_();
 112   3                  _nop_();
 113   3                  _nop_();
 114   3              }
 115   2          }
 116   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 23:46:49 PAGE 3   

 117          
 118          void main()
 119          {
 120   1        setup();
 121   1        EA = 1; // Global Interrupt Enable
 122   1      
 123   1        while(1)
 124   1        {
 125   2          switch (state) {
 126   3          case SLEEP:
 127   3            
 128   3            PCON = 0x02; // Stop/PowerDown Mode
 129   3      
 130   3            // Normally we would check here for (button_changed && button_state == LOW)
 131   3            // but debouncing would take too much time, we would enter powerDown mode again
 132   3            // before the button is debounced.
 133   3          
 134   3            O_AVR_BUTTON = LOW;
 135   3            delay(1); // otherwise the fw hangs up
 136   3            O_BOOST = HIGH;
 137   3            state = BOOT;
 138   3            
 139   3            break;
 140   3      
 141   3          case BOOT:
 142   3            O_AVR_BUTTON = button_state;
 143   3      
 144   3            if (avr_online_state == HIGH)
 145   3              state = ONLINE;
 146   3      
 147   3            // TODO: Timeout
 148   3            break;
 149   3      
 150   3          case ONLINE:
 151   3            O_AVR_BUTTON = button_state;
 152   3      
 153   3            if (avr_online_state == LOW) {
 154   4              O_BOOST = LOW;
 155   4              state = SLEEP;
 156   4            }
 157   3            break;
 158   3      
 159   3          default:
 160   3            state = SLEEP;
 161   3            break;
 162   3          }
 163   2      
 164   2      }
 165   1      
 166   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    526    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
