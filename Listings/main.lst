C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 13:33:18 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.h>
   2          #include <intrins.h>
   3          
   4          #define LOW   0
   5          #define HIGH  1
   6          #define FALSE 0
   7          #define TRUE  1
   8          
   9          // I/O Ports
  10          #define I_BUTTON      P34
  11          #define I_AVR_ONLINE  P33 // PD2
  12          #define O_BOOST       P35
  13          #define O_AVR_BUTTON  P32 // PD1
  14          
  15          // States
  16          #define SLEEP   0
  17          #define BOOT    1
  18          #define ONLINE  2
  19          
  20          #define CLR_BIT(p,n) ((p) &= ~(1 << (n)))
  21          #define SET_BIT(p,n) ((p) |= (1 << (n)))
  22          
  23          volatile int state;
  24          volatile int button_changed;
  25          volatile int button_state;
  26          volatile int avr_online_state;
  27          
  28          void timer0_ISR (void) interrupt 1
  29          {
  30   1        static float avg_button = 10;
  31   1        static float avg_avr_online = 10;
  32   1      
  33   1        int new_button_state;
  34   1        int new_avr_online_state;
  35   1      
  36   1        // Increment Counter to shorten overflow time
  37   1        TH0 = (65536 - 1000) / 256; // TODO: Calculation?! Old: 1ms = 1000MZ, davon das High-Byte in TH0
  38   1        TL0 = (65536 - 1000) % 256; // das Low-Byte in TL0
  39   1      
  40   1        // Button debouncing using exponential moving average
  41   1        // avg = alpha * avg + (1 - alpha) * input, alpha < 1
  42   1        // TODO: inefficient, replace
  43   1        avg_button     = 0.9 * avg_button + 0.1 * (I_BUTTON * 10);
  44   1        avg_avr_online = 0.9 * avg_avr_online + 0.1 * (I_AVR_ONLINE * 10);
  45   1      
  46   1        (avg_button > 5) ? (new_button_state = HIGH) : (new_button_state = LOW);
  47   1        (avg_avr_online > 5) ? (new_avr_online_state = HIGH) : (new_avr_online_state = LOW);
  48   1      
  49   1        if (new_button_state != button_state) {
  50   2          button_state = new_button_state;
  51   2          button_changed = 1;
  52   2        } else {
  53   2          button_changed = 0;
  54   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 13:33:18 PAGE 2   

  55   1      
  56   1        if (new_avr_online_state != avr_online_state) {
  57   2          avr_online_state = new_avr_online_state;
  58   2        }
  59   1      }
  60          
  61          
  62          void setup()
  63          {
  64   1        // Keep P33 (I_AVR_ONLINE) and P34 (I_BUTTON) as Quasi-Bidirectional
  65   1        // since we need the internal PullUps
  66   1      
  67   1        // P35 (O_BOOST): PushPull Output
  68   1        SET_BIT(P3M0, 5); // P3M0 |= 1 << 5;
  69   1        CLR_BIT(P3M1, 5); // P3M1 &= ~(0 << 5);
  70   1      
  71   1        // P32 (O_AVR_BUTTON): PushPull Output
  72   1        SET_BIT(P3M1, 2); // P3M0 |= 1 << 2;
  73   1        CLR_BIT(P3M1, 2); // P3M1 &= ~(0 << 2);
  74   1      
  75   1        // Init States
  76   1        state = SLEEP;
  77   1        
  78   1        button_changed = FALSE;
  79   1        button_state = HIGH;
  80   1        avr_online_state = LOW;
  81   1      
  82   1        // Init I/O's
  83   1        O_AVR_BUTTON = HIGH;
  84   1        O_BOOST = LOW;
  85   1        I_BUTTON = HIGH;     // set to weak high => pullups!
  86   1        I_AVR_ONLINE = HIGH; // set to weak high => pullups!
  87   1      
  88   1        // Timers
  89   1        TMOD = (TMOD & 0xF0) | 0x01;  // Set T/C0 Mode 1, 16Bit, Manual Reload
  90   1        ET0 = 1;                      // Enable Timer 0 Interrupts
  91   1        TR0 = 1;                      // Start Timer 0 Running
  92   1        EA = 1;                       // Global Interrupt Enable
  93   1      }
  94          
  95          void delay(int ms)
  96          {
  97   1          unsigned int j  =   0;
  98   1          unsigned int g  =   0;
  99   1          for(j=0;j<ms;j++)
 100   1          {
 101   2              for(g=0;g<600;g++)
 102   2              {
 103   3                  _nop_();
 104   3                  _nop_();
 105   3                  _nop_();
 106   3                  _nop_();
 107   3                  _nop_();
 108   3              }
 109   2          }
 110   1      }
 111          
 112          void main()
 113          {
 114   1        setup();
 115   1      
 116   1        while(1)
C51 COMPILER V9.59.0.0   MAIN                                                              09/10/2018 13:33:18 PAGE 3   

 117   1        {
 118   2          switch (state) {
 119   3          case SLEEP:
 120   3            // TODO: POWER SAVING OPTIONS
 121   3            // deactivate timer, enable interrupt2, ...
 122   3      
 123   3            if (button_changed && button_state == LOW) {
 124   4              O_AVR_BUTTON = LOW;
 125   4              delay(1); // otherwise the fw hangs up
 126   4              O_BOOST = HIGH;
 127   4              state = BOOT;
 128   4            }
 129   3            break;
 130   3      
 131   3          case BOOT:
 132   3            O_AVR_BUTTON = button_state;
 133   3      
 134   3            if (avr_online_state == HIGH)
 135   3              state = ONLINE;
 136   3      
 137   3            // TODO: Timeout
 138   3            break;
 139   3      
 140   3          case ONLINE:
 141   3            O_AVR_BUTTON = button_state;
 142   3      
 143   3            if (avr_online_state == LOW) {
 144   4              O_BOOST = LOW;
 145   4              state = SLEEP;
 146   4            }
 147   3            break;
 148   3      
 149   3          default:
 150   3            state = SLEEP;
 151   3            break;
 152   3          }
 153   2      
 154   2      }
 155   1      
 156   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    529    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
