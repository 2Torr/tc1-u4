C51 COMPILER V9.59.0.0   MAIN                                                              09/14/2018 13:23:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.h>
   2          #include <intrins.h>
   3          
   4          #define LOW   0
   5          #define HIGH  1
   6          #define FALSE 0
   7          #define TRUE  1
   8          
   9          #define CLR_BIT(p,n) ((p) &= ~(1 << (n)))
  10          #define SET_BIT(p,n) ((p) |= (1 << (n)))
  11          
  12          // I/O Ports
  13          #define I_BUTTON      P34
  14          #define I_AVR_ONLINE  P33 // PD2
  15          #define O_BOOST       P35
  16          #define O_AVR_BUTTON  P32 // PD1
  17          
  18          // States
  19          #define SLEEP   0
  20          #define BOOT    1
  21          #define ONLINE  2
  22          
  23          volatile int state;
  24          volatile int system_tick;
  25          
  26          volatile int button_changed;
  27          volatile int button_state;
  28          volatile int avr_online_state;
  29          
  30          
  31          void extInt2_ISR (void) interrupt 10
  32          {
  33   1        // do nothing, INT2's only purpose is to wake up the system
  34   1      }
  35          
  36          void timer0_ISR(void) interrupt 1
  37          {
  38   1        system_tick++;
  39   1      
  40   1        /* NOTE: How long takes a system tick?
  41   1         *
  42   1         * The calculation goes like:
  43   1         * tick frequenycy =
  44   1         * system frequency / 12 / (65536 - [RL_TH0, RL_TL0])
  45   1         *
  46   1         * The '12' is because we set the AUXR register to call the
  47   1         * timer ISR only every 12th clock cycle.
  48   1         *
  49   1         * Supposing that the system clock is set to 12.000 MHz, and
  50   1         * [RL_TH0, RL_TL0] is "65536 - 1000", then a system-tick would be
  51   1         * 12 MHz / 12 / 1000 = 1 kHz.
  52   1         *
  53   1         * Therefore a system tick would take 1ms
  54   1         */
C51 COMPILER V9.59.0.0   MAIN                                                              09/14/2018 13:23:19 PAGE 2   

  55   1      }
  56          
  57          void timer1_ISR(void) interrupt 3
  58          {
  59   1        static float avg_button = 10;
  60   1        static float avg_avr_online = 10;
  61   1      
  62   1        int new_button_state;
  63   1        int new_avr_online_state;
  64   1      
  65   1        // Button debouncing using exponential moving average
  66   1        // avg = alpha * avg + (1 - alpha) * input, alpha < 1
  67   1        // TODO: inefficient, replace
  68   1        avg_button     = 0.9 * avg_button + 0.1 * (I_BUTTON * 10);
  69   1        avg_avr_online = 0.9 * avg_avr_online + 0.1 * (I_AVR_ONLINE * 10);
  70   1      
  71   1        (avg_button > 5) ? (new_button_state = HIGH) : (new_button_state = LOW);
  72   1        (avg_avr_online > 5) ? (new_avr_online_state = HIGH) : (new_avr_online_state = LOW);
  73   1      
  74   1        if (new_button_state != button_state) {
  75   2          button_state = new_button_state;
  76   2          button_changed = 1;
  77   2        } else {
  78   2          button_changed = 0;
  79   2        }
  80   1      
  81   1        if (new_avr_online_state != avr_online_state) {
  82   2          avr_online_state = new_avr_online_state;
  83   2        }
  84   1      }
  85          
  86          void setup()
  87          {
  88   1        // Keep P33 (I_AVR_ONLINE) and P34 (I_BUTTON) as Quasi-Bidirectional
  89   1        // since we need the internal PullUps
  90   1      
  91   1        // P35 (O_BOOST): PushPull Output
  92   1        SET_BIT(P3M0, 5);
  93   1        CLR_BIT(P3M1, 5);
  94   1      
  95   1        // P32 (O_AVR_BUTTON): PushPull Output
  96   1        SET_BIT(P3M0, 2);
  97   1        CLR_BIT(P3M1, 2);
  98   1      
  99   1        // Init States
 100   1        state = SLEEP;
 101   1        system_tick = 0;
 102   1      
 103   1        button_changed = FALSE;
 104   1        button_state = HIGH;
 105   1        avr_online_state = LOW;
 106   1      
 107   1        // Init I/O's
 108   1        O_AVR_BUTTON = LOW;  // we can keep this signal low since the ATmega is not yet up, even if low means "pr
             -essed"
 109   1        O_BOOST = LOW;
 110   1        I_BUTTON = HIGH;     // set to weak high => pullups!
 111   1        I_AVR_ONLINE = HIGH; // set to weak high => pullups!
 112   1      
 113   1        // Timers & Interrupts
 114   1        SET_BIT(INT_CLKO, 4);         // Interrupt on falling edge of INT2/P34 (Button)
 115   1      
C51 COMPILER V9.59.0.0   MAIN                                                              09/14/2018 13:23:19 PAGE 3   

 116   1        // Timer 0
 117   1        TMOD &= 0xF0;     // Mode 0, 16Bit, Auto Reload
 118   1        CLR_BIT(AUXR, 7); // 12T Mode
 119   1        TH0 = (65536 - 1000) / 256; // Reload values after overflow, High value
 120   1        TL0 = (65536 - 1000) % 256; // Low value
 121   1      
 122   1        // Timer 1
 123   1        TMOD &= 0x0F;      // Set T/C1 Mode 0, 16Bit, Auto Reload
 124   1        CLR_BIT(AUXR, 6);  // Timer 1 in 12T mode, not 1T mode.
 125   1        /* NOTE on Reload Values for STC15 uC:
 126   1         * Any value written into TH0/TL0 are passed to the reload registers
 127   1         * RL_TH0/TL0 as long as TR0=0.
 128   1         * If TR0=1, then the values are written into the hidden reload registers only.
 129   1         */
 130   1        TH1 = (65536 - 500) / 256; // High byte reload value
 131   1        TL1 = (65536 - 500) % 256; // Low byte reload value
 132   1      
 133   1        ET0 = 1; // Enable Timer 0 interrupts
 134   1        ET1 = 1; // Enable Timer 1 interrupts
 135   1      
 136   1        TR0 = 1; // Start Timer 0
 137   1        TR1 = 1; // Start Timer 1
 138   1      }
 139          
 140          void delay(int ms)
 141          {
 142   1        unsigned int j  =   0;
 143   1        unsigned int g  =   0;
 144   1        for(j=0;j<ms;j++)
 145   1        {
 146   2          for(g=0;g<600;g++)
 147   2          {
 148   3            _nop_();
 149   3            _nop_();
 150   3            _nop_();
 151   3            _nop_();
 152   3            _nop_();
 153   3          }
 154   2        }
 155   1      }
 156          
 157          void main()
 158          {
 159   1        setup();
 160   1        EA = 1; // Global Interrupt Enable
 161   1      
 162   1        while(1)
 163   1        {
 164   2          switch (state) {
 165   3          case SLEEP:
 166   3            PCON = 0x02; // Stop/PowerDown Mode
 167   3      
 168   3            // Normally we would check here for (button_changed && button_state == LOW)
 169   3            // but debouncing would take too much time, we would enter powerDown mode again
 170   3            // before the button is debounced.
 171   3      
 172   3            O_AVR_BUTTON = LOW;
 173   3            delay(1); // TODO: otherwise the fw hangs up, maybe we should switch both?
 174   3            O_BOOST = HIGH;
 175   3            state = BOOT;
 176   3      
 177   3            break;
C51 COMPILER V9.59.0.0   MAIN                                                              09/14/2018 13:23:19 PAGE 4   

 178   3      
 179   3          case BOOT:
 180   3            O_AVR_BUTTON = button_state;
 181   3      
 182   3            if (avr_online_state == HIGH)
 183   3              state = ONLINE;
 184   3      
 185   3            // TODO: Timeout
 186   3            break;
 187   3      
 188   3          case ONLINE:
 189   3            O_AVR_BUTTON = button_state;
 190   3      
 191   3            if (avr_online_state == LOW) {
 192   4              O_BOOST = LOW;
 193   4              state = SLEEP;
 194   4            }
 195   3            break;
 196   3      
 197   3          default:
 198   3            state = SLEEP;
 199   3            break;
 200   3          }
 201   2      
 202   2        }
 203   1      
 204   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    556    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
